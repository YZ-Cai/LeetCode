"""
你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 m x n 的矩阵表示， 在这个矩阵中：

0 表示障碍，无法触碰
1 表示地面，可以行走
比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度
每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。

你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 1（即变为地面）。

你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。

可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/cut-off-trees-for-golf-event
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""
from typing import List
from collections import deque


# 2022/05/23
class Solution:
    def cutOffTree(self, forest: List[List[int]]) -> int:
        m = len(forest)
        n = len(forest[0])
        self.neighbors = [[[] for i in range(n)] for j in range(m)]
        trees = []

        d = [(0,1), (0,-1), (-1,0), (1,0)]
        for i in range(m):
            for j in range(n):
                if forest[i][j]>0:
                    if forest[i][j]>1:
                        trees.append((forest[i][j], i, j))
                    for di, dj in d:
                        if i+di>=0 and i+di<m and j+dj>=0 and j+dj<n and forest[i+di][j+dj]>0:
                            self.neighbors[i][j].append((i+di, j+dj))
        
        trees = sorted(trees, key=lambda x:x[0])
        cur = (0, 0)
        ans = 0
        for _, i, j in trees:
            cost = self.BFS(cur, (i,j))
            if cost==-1:
                return -1
            ans += cost
            cur = (i,j)
        return ans


    def BFS(self, s, t):
        if s==t:
            return 0
        q = deque([(s[0], s[1], 0)])
        visited = {s}

        while q:
            i, j, k = q.popleft()
            for nxt in self.neighbors[i][j]:
                if nxt==t:
                    return k+1
                if nxt not in visited:
                    visited.add((nxt[0], nxt[1]))
                    q.append((nxt[0], nxt[1], k+1))
        return -1



if __name__ == '__main__':

    # inputs
    forest = [[69438,55243,0,43779,5241,93591,73380],[847,49990,53242,21837,89404,63929,48214],[90332,49751,0,3088,16374,70121,25385],[14694,4338,87873,86281,5204,84169,5024],[31711,47313,1885,28332,11646,42583,31460],[59845,94855,29286,53221,9803,41305,60749],[95077,50343,27947,92852,0,0,19731],[86158,63553,56822,90251,0,23826,17478],[60387,23279,78048,78835,5310,99720,0],[74799,48845,60658,29773,96129,90443,14391],[65448,63358,78089,93914,7931,68804,72633],[93431,90868,55280,30860,59354,62083,47669],[81064,93220,22386,22341,95485,20696,13436],[50083,0,89399,43882,0,13593,27847],[0,12256,33652,69301,73395,93440,0],[42818,87197,81249,33936,7027,5744,64710],[35843,0,99746,52442,17494,49407,63016],[86042,44524,0,0,26787,97651,28572],[54183,83466,96754,89861,84143,13413,72921],[89405,52305,39907,27366,14603,0,14104],[70909,61104,70236,30365,0,30944,98378],[20124,87188,6515,98319,78146,99325,88919],[89669,0,64218,85795,2449,48939,12869],[93539,28909,90973,77642,0,72170,98359],[88628,16422,80512,0,38651,50854,55768],[13639,2889,74835,80416,26051,78859,25721],[90182,23154,16586,0,27459,3272,84893],[2480,33654,87321,93272,93079,0,38394],[34676,72427,95024,12240,72012,0,57763],[97957,56,83817,45472,0,24087,90245],[32056,0,92049,21380,4980,38458,3490],[21509,76628,0,90430,10113,76264,45840],[97192,58807,74165,65921,45726,47265,56084],[16276,27751,37985,47944,54895,80706,2372],[28438,53073,0,67255,38416,63354,69262],[23926,75497,91347,58436,73946,39565,10841],[34372,69647,44093,62680,32424,69858,68719],[24425,4014,94871,1031,99852,88692,31503],[24475,12295,33326,37771,37883,74568,25163],[0,18411,88185,60924,29028,69789,0],[34697,75631,7636,16190,60178,39082,7052],[24876,9570,53630,98605,22331,79320,88317],[27204,89103,15221,91346,35428,94251,62745],[26636,28759,12998,58412,38113,14678,0],[80871,79706,45325,3861,12504,0,4872],[79662,15626,995,80546,64775,0,68820],[25160,82123,81706,21494,92958,33594,5243]]

    # solution
    ans = Solution().cutOffTree(forest)

    # outputs
    print(ans)

